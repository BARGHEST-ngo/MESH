import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import apiClient from './client'
import type { V1User, V1CreateUserRequest, V1ListUsersResponse, V1DeleteUserResponse } from './openapi/types.gen'
import type { V1GetPolicyResponse, V1SetPolicyResponse } from './openapi/types.gen'
import { parseHuJSON, toHuJSON } from './usePolicy'
import { generateNetworkIsolationPolicy } from '../lib/aclPolicyGenerator'
import type { ACLRule } from './usePolicy'

/**
 * Network (User) Management Hooks
 * 
 * In Headscale, "Users" act as network namespaces.
 */

type PolicyStruct = {
    acls?: ACLRule[]
    tagOwners?: Record<string, string[]>
    [k: string]: unknown
}

export function useNetworks() {
    return useQuery({
        queryKey: ['networks'],
        queryFn: async () => {
            const response = await apiClient.get<V1ListUsersResponse>('/user')
            return response.data.users || []
        },
    })
}

function isMissingPolicyError(err: unknown): boolean {
    const anyErr = err as any
    const status: number | undefined = anyErr?.response?.status
    const message: string = String(
        anyErr?.response?.data?.message ??
        anyErr?.message ??
        anyErr?.response?.data ??
        ''
    )
    return status === 500 && message.toLowerCase().includes('acl policy not found')
}

async function syncNetworkIsolationPolicy(): Promise<void> {
    let currentPolicy: PolicyStruct
    const networksResponse = await apiClient.get<V1ListUsersResponse>('/user')
    const networks = networksResponse.data.users || []

    try {
        const currentPolicyResponse = await apiClient.get<V1GetPolicyResponse>('/policy')
        const currentRaw = currentPolicyResponse.data.policy || '{}'
        currentPolicy = (parseHuJSON(currentRaw) || {}) as PolicyStruct
    } catch (err) {
        if (!isMissingPolicyError(err)) throw err
        currentPolicy = { acls: [], tagOwners: {} }
    }

    const existingAcls = (currentPolicy.acls as ACLRule[]) || []
	const existingTagOwners = (currentPolicy.tagOwners as Record<string, string[]>) || {}

    const customRules = existingAcls.filter(rule => !isAutoGeneratedIsolationRule(rule))
    
    const generatedPolicy = generateNetworkIsolationPolicy(networks)
    const isolationRules = generatedPolicy.acls || []
	const generatedTagOwners = generatedPolicy.tagOwners || {}
    
    const mergedAcls = [...customRules, ...isolationRules]
	
    const customTagOwners = Object.fromEntries(
		Object.entries(existingTagOwners).filter(([tag]) => !isAutoGeneratedNetworkTag(tag))
	)
	
    const mergedTagOwners = { ...customTagOwners, ...generatedTagOwners }
    
    const mergedPolicy = {
        ...currentPolicy,
        acls: mergedAcls,
		tagOwners: mergedTagOwners,
    }
    
    await apiClient.put<V1SetPolicyResponse>('/policy', {
        policy: toHuJSON(mergedPolicy),
    })
}


function isAutoGeneratedIsolationRule(rule: ACLRule): boolean {
    if (rule.action !== 'accept') return false
    if (!rule.src || rule.src.length !== 1) return false
    if (!rule.dst || rule.dst.length !== 1) return false
    
    const srcPattern = rule.src[0]
    const dstPattern = rule.dst[0]

	// New (tag-based) auto-generated rule:
	//   src: ["tag:net-..."]
	//   dst: ["tag:net-...:*"]
	if (srcPattern.startsWith('tag:net-')) {
		return dstPattern === `${srcPattern}:*`
	}

	// Legacy (user-owned) auto-generated rule:
	//   src: ["NetworkName@"]
	//   dst: ["NetworkName@:*"]
	if (srcPattern.endsWith('@')) {
		const networkName = srcPattern.slice(0, -1)
		const expectedDst = `${networkName}@:*`
		return dstPattern === expectedDst
	}

	return false
}

function isAutoGeneratedNetworkTag(tag: string): boolean {
	return typeof tag === 'string' && tag.startsWith('tag:net-')
}

export function useCreateNetwork() {
    const queryClient = useQueryClient()

    return useMutation({
        mutationFn: async (data: { name: string; displayName?: string; email?: string }) => {
            const request: V1CreateUserRequest = {
                name: data.name,
                displayName: data.displayName,
                email: data.email,
            }

            // Create the network first
            const response = await apiClient.post('/user', request)

            try {
                await syncNetworkIsolationPolicy()
            } catch (aclError) {
                console.error('Failed to sync ACL policy after network creation:', aclError)
            }

            return response.data
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['networks'] })
            queryClient.invalidateQueries({ queryKey: ['policy'] })
        },
    })
}

export function useRenameNetwork() {
    const queryClient = useQueryClient()

    return useMutation({
        mutationFn: async (data: { user: V1User; newName: string }) => {
            if (!data.user.id) {
                throw new Error('User ID is required')
            }

            const response = await apiClient.post(`/user/${data.user.id}/rename/${data.newName}`)

           
            try {
                await syncNetworkIsolationPolicy()
            } catch (aclError) {
                console.error('Failed to sync ACL policy after network rename:', aclError)
            }

            return response.data
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['networks'] })
            queryClient.invalidateQueries({ queryKey: ['nodes'] })
            queryClient.invalidateQueries({ queryKey: ['policy'] })
        },
    })
}

export function useDeleteNetwork() {
    const queryClient = useQueryClient()

    return useMutation({
        mutationFn: async (user: V1User) => {
            if (!user.id) {
                throw new Error('User ID is required')
            }

            // Delete the network first
            const response = await apiClient.delete<V1DeleteUserResponse>(`/user/${user.id}`)

            // Sync ACL policy to remove the deleted network's rule
            // This regenerates the entire policy to ensure consistency
            try {
                await syncNetworkIsolationPolicy()
            } catch (aclError) {
                console.error('Failed to sync ACL policy after network deletion:', aclError)
            }

            return response.data
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['networks'] })
            queryClient.invalidateQueries({ queryKey: ['nodes'] })
            queryClient.invalidateQueries({ queryKey: ['policy'] })
        },
    })
}



